from threading import Event, Lock
from time import sleep
from typing import Callable
from functools import wraps, partial


def prefix_range_end(prefix):
    """Create a bytestring that can be used as a range_end for a prefix."""
    s = bytearray(prefix)
    for i in reversed(range(len(s))):
        if s[i] < 0xff:
            s[i] = s[i] + 1
            break
    return bytes(s)


def to_bytes(maybe_bytestring):
    """
    Encode string to bytes.

    Convenience function to do a simple encode('utf-8') if the input is not
    already bytes. Returns the data unmodified if the input is bytes.
    """
    if isinstance(maybe_bytestring, bytes):
        return maybe_bytestring
    else:
        return maybe_bytestring.encode('utf-8')


def lease_to_id(lease):
    """Figure out if the argument is a Lease object, or the lease ID."""
    lease_id = 0
    if hasattr(lease, 'id'):
        lease_id = lease.id
    else:
        try:
            lease_id = int(lease)
        except TypeError:
            pass
    return lease_id


def response_to_event_iterator(response_iterator):
    """Convert a watch response iterator to an event iterator."""
    for response in response_iterator:
        for event in response.events:
            yield event


class CallLock(object):
  """
  An internal object, that is used to track
  multiple call, and passing the result.

  Outside user should have no need for this class

  Have tried using @dataclass,
  but it caused the event `ev` to be created only once
  and shared between all request later,
  causing subsequent request to get wrong result/err
  """
  def __init__(self):
    super().__init__()
    self.ev = Event()
    self.res = None
    self.err = None

class SingleFlight(object):
  """
  SingleFlight's support of python's multi-threading

  An application only need one of this object, 
  as it can manage lots of call at the same time

  Object generated by this class is thread-safe
  """
  def __init__(self):
    super().__init__()
    self.lock = Lock()
    self.m = {}

  def call(self, fn: Callable[[any], any], key: str, *args, **kwargs) -> any:
    """
    Call `fn` with the given `*args` and `**kwargs` exactly once

    `key` are used to detect and coalesce duplicate call

    `key` is only hold for the duration of this function, after that it will be removed and `key` can be used again
    """
    if not isinstance(key, str):
      raise TypeError("Key should be a str")
    if not isinstance(fn, Callable):
      raise TypeError("fn should be a callable")

    # this part does not use with-statement
    # because the one need to be waited is different object (self.lock vs self.m[key].ev)
    self.lock.acquire(True)
    if key in self.m:
      # key exists here means 
      # another thread is currently making the call
      # just need to wait
      cl = self.m[key]
      self.lock.release()
      cl.ev.wait()

      if cl.err:
        raise cl.err
      return cl.res

    cl = CallLock()
    self.m[key] = cl
    self.lock.release()

    try:
      cl.res = fn(*args, **kwargs)
      cl.err = None
    except Exception as e:
      cl.res = None
      cl.err = e
    finally:
      cl.ev.set()
    
    # delete the calllock, so next call
    # with same key can pass through
    with self.lock:
      del(self.m[key])

    if cl.err is not None:
      raise cl.err
    return cl.res

  def wrap(self, fn: Callable[[any], any]):
    """ simple wrapper for SingleFlight.call """
    @wraps(fn)
    def wrapper(*args, **kwargs):
      return partial(self.call, fn, *args, **kwargs)

    return wrapper()
  

refresh_token_sf = SingleFlight()